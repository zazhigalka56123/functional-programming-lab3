# Лабораторная работа №3

**Выполнил:** Пасечник Иван Андреевич  
**Группа:** P3331  
**Преподаватель:** Пенской Александр Владимирович  
**Язык:** Clojure

---

## Тема

**Потоковая интерполяция с поддержкой нескольких алгоритмов**

---

## Цель работы

Получить навыки работы с вводом/выводом, потоковой обработкой данных и командной строкой в функциональном стиле:

- чтение данных из stdin в потоковом режиме;
- вывод результатов в stdout по мере поступления данных;
- парсинг аргументов командной строки;
- разделение I/O от алгоритмов интерполяции;
- использование ленивых последовательностей и функций высшего порядка.

---

## Реализованные алгоритмы

| Алгоритм | Описание | Минимум точек |
|----------|----------|---------------|
| Linear | Линейная интерполяция отрезками | 2 |
| Lagrange | Интерполяционный полином Лагранжа | n |
| Newton | Полином Ньютона с разделёнными разностями | n |

---

## Архитектура

```
+---------------------------+
| обработка входного потока |  <- io.clj
+---------------------------+
            |
            | поток точек {:x ... :y ...}
            v
+-----------------------+      +------------------------------+
| алгоритм интерполяции |<-----| генератор x-координат        |
| (algorithms.clj)      |      | (streaming.clj)              |
+-----------------------+      +------------------------------+
            |
            | поток рассчитанных точек
            v
+------------------------+
| печать выходных данных |  <- io.clj
+------------------------+
```

### Модули

| Файл | Назначение |
|------|------------|
| `core.clj` | Точка входа, композиция pipeline ([`core.clj:1-18`](src/interpolation/core.clj#L1-L18)) |
| `cli.clj` | Парсинг аргументов командной строки ([`cli.clj:1-49`](src/interpolation/cli.clj#L1-L49)) |
| `io.clj` | Чтение stdin / вывод в stdout ([`io.clj:1-26`](src/interpolation/io.clj#L1-L26)) |
| `algorithms.clj` | Чистые функции интерполяции ([`algorithms.clj:1-97`](src/interpolation/algorithms.clj#L1-L97)) |
| `streaming.clj` | Потоковая обработка со скользящим окном ([`streaming.clj:1-127`](src/interpolation/streaming.clj#L1-L127)) |

---

## Реализация алгоритмов

### Линейная интерполяция

Простейший метод — соединение соседних точек отрезками:

$$y = y_1 + \frac{y_2 - y_1}{x_2 - x_1}(x - x_1)$$

Реализация ([`algorithms.clj:4-13`](src/interpolation/algorithms.clj#L4-L13)):
```clojure
(defn linear-interpolate [points x]
  (let [{x1 :x y1 :y} (first points)
        {x2 :x y2 :y} (second points)]
    (+ y1 (* (- y2 y1) (/ (- x x1) (- x2 x1))))))
```

### Интерполяция Лагранжа

Полином степени n-1 через n точек:

$$L(x) = \sum_{i=0}^{n-1} y_i \prod_{j \neq i} \frac{x - x_j}{x_i - x_j}$$

Реализация ([`algorithms.clj:52-77`](src/interpolation/algorithms.clj#L52-L77)):
```clojure
(defn lagrange-interpolate [points x]
  (let [n (count points)]
    (reduce
     (fn [sum i]
       (+ sum (* (:y (nth points i)) (lagrange-basis points i x))))
     0.0
     (range n))))
```

### Интерполяция Ньютона

Использует разделённые разности для построения полинома:

$$N(x) = f[x_0] + f[x_0,x_1](x-x_0) + f[x_0,x_1,x_2](x-x_0)(x-x_1) + \ldots$$

Вычисление разделённых разностей ([`algorithms.clj:16-33`](src/interpolation/algorithms.clj#L16-L33)):
```clojure
(defn- compute-divided-differences [points]
  (let [n (count points)
        xs (mapv :x points)
        ys (mapv :y points)]
    (loop [table [ys]
           k 1]
      (if (>= k n)
        (mapv first table)
        (let [prev (last table)
              next-col (vec (map-indexed
                             (fn [i _]
                               (/ (- (nth prev (inc i)) (nth prev i))
                                  (- (nth xs (+ i k)) (nth xs i))))
                             (range (- n k))))]
          (recur (conj table next-col) (inc k)))))))
```

---

## Потоковая обработка

Программа работает в потоковом режиме — выдаёт результаты по мере поступления данных:

```
o o o o o o . . x x x
  x x x . . o . . x x x
    x x x . . o . . x x x
      x x x . . o . . x x x
            x x x . . o o o o o o EOF
```

где:
- `o` — рассчитанные точки (выводятся сразу)
- `.` — точки в текущем окне
- `x` — точки вне окна

Реализация скользящего окна ([`streaming.clj:80-120`](src/interpolation/streaming.clj#L80-L120)).

---

## Использование

### Аргументы командной строки

| Опция | Описание | По умолчанию |
|-------|----------|--------------|
| `-l`, `--linear` | Линейная интерполяция | — |
| `-L`, `--lagrange` | Интерполяция Лагранжа | — |
| `-N`, `--newton` | Интерполяция Ньютона | — |
| `-s`, `--step STEP` | Шаг дискретизации | 1.0 |
| `-n`, `--points N` | Размер окна для Лагранжа/Ньютона | 4 |
| `-h`, `--help` | Показать справку | — |

### Формат данных

**Вход** (stdin): `x y` или `x<tab>y` — по одной точке на строку, отсортировано по x  
**Выход** (stdout): `algorithm: x y`

### Примеры

```bash
# Линейная интерполяция
$ echo -e "0 0\n1 1\n2 4" | lein run -- --linear --step 0.5
linear: 0.0000 0.0000
linear: 0.5000 0.5000
linear: 1.0000 1.0000
linear: 1.5000 2.5000
linear: 2.0000 4.0000

# Интерполяция Ньютона (y = x²)
$ echo -e "0 0\n1 1\n2 4\n3 9" | lein run -- --newton -n 3 --step 0.5
newton: 0.0000 0.0000
newton: 0.5000 0.2500
newton: 1.0000 1.0000
newton: 1.5000 2.2500
newton: 2.0000 4.0000
newton: 2.5000 6.2500
newton: 3.0000 9.0000

# Несколько алгоритмов одновременно
$ echo -e "0 0\n1 1\n2 4" | lein run -- --linear --lagrange -n 3 --step 1
linear: 0.0000 0.0000
linear: 1.0000 1.0000
linear: 2.0000 4.0000
lagrange: 0.0000 0.0000
lagrange: 1.0000 1.0000
lagrange: 2.0000 4.0000
```

---

## Тестирование

### Unit-тесты ([`test/interpolation/core_test.clj`](test/interpolation/core_test.clj))

Покрывают:
- корректность линейной интерполяции ([`core_test.clj:13-30`](test/interpolation/core_test.clj#L13-L30));
- корректность интерполяции Ньютона ([`core_test.clj:33-52`](test/interpolation/core_test.clj#L33-L52));
- корректность интерполяции Лагранжа ([`core_test.clj:55-73`](test/interpolation/core_test.clj#L55-L73));
- эквивалентность результатов Ньютона и Лагранжа ([`core_test.clj:69-73`](test/interpolation/core_test.clj#L69-L73));
- парсинг аргументов CLI ([`core_test.clj:76-99`](test/interpolation/core_test.clj#L76-L99));
- парсинг и форматирование I/O ([`core_test.clj:102-118`](test/interpolation/core_test.clj#L102-L118)).

### Запуск

```bash
# Запуск тестов
$ lein test

# Проверка форматирования
$ lein cljfmt check
```

**Результат:** 7 тестов, 58 assertions, 0 failures.

---

## Выводы

В ходе лабораторной работы я:

- реализовал потоковую интерполяцию с тремя алгоритмами (линейная, Лагранж, Ньютон);
- применил **функциональный стиль**: чистые функции для алгоритмов, ленивые последовательности для потоковой обработки;
- разделил ответственность между модулями: парсинг, форматирование, алгоритмы, потоковая логика;
- использовал идиоматичные приёмы Clojure:
  - `loop/recur` для хвостовой рекурсии в вычислении разделённых разностей;
  - `reduce` для построения сумм в интерполяции Лагранжа;
  - `iterate` и `take-while` для ленивой генерации x-координат;
  - функции высшего порядка (`map`, `filter`, `mapcat`) для обработки коллекций;
- обеспечил **разделение I/O от бизнес-логики**: все алгоритмы — чистые функции без побочных эффектов;
- настроил CI с тестами и линтером.
