# Лабораторная работа №3

**Выполнил:** Пасечник Иван Андреевич  
**Группа:** P3331  
**Преподаватель:** Пенской Александр Владимирович  
**Язык:** Clojure

---

## Тема

**Потоковая интерполяция**

---

## Цель работы

Получить навыки работы с вводом/выводом, потоковой обработкой данных и командной строкой в функциональном стиле:

- чтение данных из stdin в потоковом режиме;
- вывод результатов в stdout по мере поступления данных;
- парсинг аргументов командной строки;
- разделение I/O от алгоритмов интерполяции;
- использование ленивых последовательностей и функций высшего порядка.

---

## Реализованные алгоритмы

| Алгоритм | Описание | Минимум точек |
|----------|----------|---------------|
| Linear | Линейная интерполяция отрезками | 2 |
| Lagrange | Интерполяционный полином Лагранжа | n |
| Newton | Полином Ньютона с разделёнными разностями | n |

---

## Архитектура

```
+---------------------------+
| обработка входного потока |  <- io.clj
+---------------------------+
            |
            | поток точек {:x ... :y ...}
            v
+-----------------------+      +------------------------------+
| алгоритм интерполяции |<-----| генератор x-координат        |
| (algorithms.clj)      |      | (streaming.clj)              |
+-----------------------+      +------------------------------+
            |
            | поток рассчитанных точек
            v
+------------------------+
| печать выходных данных |  <- io.clj
+------------------------+
```

### Модули

| Файл | Назначение |
|------|------------|
| `core.clj` | Точка входа, композиция pipeline |
| `cli.clj` | Парсинг аргументов командной строки |
| `io.clj` | Чтение stdin / вывод в stdout |
| `algorithms.clj` | Чистые функции интерполяции (defmulti interpolate) |
| `streaming.clj` | Потоковая обработка со скользящим окном |

---

## Реализация алгоритмов

### Линейная интерполяция

Простейший метод — соединение соседних точек отрезками:

$$y = y_1 + \frac{y_2 - y_1}{x_2 - x_1}(x - x_1)$$

Реализация через defmulti:
```clojure
(defmethod interpolate :linear
  [_ points x]
  (let [{x1 :x y1 :y} (first points)
        {x2 :x y2 :y} (second points)]
    (if (= x1 x2)
      y1
      (+ y1 (* (- y2 y1) (/ (- x x1) (- x2 x1)))))))
```

### Интерполяция Лагранжа

Полином степени n-1 через n точек:

$$L(x) = \sum_{i=0}^{n-1} y_i \prod_{j \neq i} \frac{x - x_j}{x_i - x_j}$$

Реализация:
```clojure
(defmethod interpolate :lagrange
  [_ points x]
  (let [n (count points)]
    (reduce
     (fn [sum i]
       (+ sum (* (:y (nth points i)) (lagrange-basis points i x))))
     0.0
     (range n))))
```

### Интерполяция Ньютона

Использует разделённые разности для построения полинома:

$$N(x) = f[x_0] + f[x_0,x_1](x-x_0) + f[x_0,x_1,x_2](x-x_0)(x-x_1) + \ldots$$

Вычисление разделённых разностей:
```clojure
(defn- compute-divided-differences [points]
  (let [n (count points)
        xs (mapv :x points)
        ys (mapv :y points)]
    (loop [table [ys]
           k 1]
      (if (>= k n)
        (mapv first table)
        (let [prev (last table)
              next-col (vec (map-indexed
                             (fn [i _]
                               (/ (- (nth prev (inc i)) (nth prev i))
                                  (- (nth xs (+ i k)) (nth xs i))))
                             (range (- n k))))]
          (recur (conj table next-col) (inc k)))))))
```

---

## Потоковая обработка

Программа работает в потоковом режиме — выдаёт результаты по мере поступления данных:

```
o o o o o o . . x x x
  x x x . . o . . x x x
    x x x . . o . . x x x
      x x x . . o . . x x x
            x x x . . o o o o o o EOF
```

где:
- `o` — рассчитанные точки (выводятся сразу)
- `.` — точки в текущем окне
- `x` — точки вне окна

### Ключевые функции streaming.clj

**interpolate-range** — единая функция интерполяции:
```clojure
(defn- interpolate-range [state x-start x-end]
  (let [{:keys [algorithm step]} state
        window (get-window state)
        results (for [x (generate-x-values x-start x-end step)]
                  {:x x :y (alg/interpolate algorithm window x)})
        new-last-x (if (seq results) (:x (last results)) (:last-x state))]
    [(assoc state :last-x new-last-x) results]))
```

**process-point** — обработка входящей точки:
```clojure
(defn process-point [state point]
  (let [state (update state :buffer conj point)]
    (if-not (has-full-window? state)
      [state []]
      (let [window (get-window state)
            {:keys [algorithm last-x step]} state
            first-window? (nil? last-x)
            x-start (if first-window? 
                      (:x (first window)) 
                      (+ last-x step))
            x-end (if (= algorithm :linear)
                    (x-end-for-linear window)
                    (x-end-for-polynomial window))]
        (interpolate-range state x-start x-end)))))
```

---

## Использование

### Аргументы командной строки

| Опция | Описание | По умолчанию |
|-------|----------|--------------|
| `-l`, `--linear` | Линейная интерполяция | — |
| `-L`, `--lagrange` | Интерполяция Лагранжа | — |
| `-N`, `--newton` | Интерполяция Ньютона | — |
| `-s`, `--step STEP` | Шаг дискретизации | 1.0 |
| `-n`, `--points N` | Размер окна для Лагранжа/Ньютона | 4 |
| `-h`, `--help` | Показать справку | — |

**Примечание:** необходимо указать ОДИН алгоритм.

### Формат данных

**Вход** (stdin): `x y` или `x<tab>y` — по одной точке на строку, отсортировано по x  
**Выход** (stdout): `algorithm: x y`

### Примеры

```bash
# Линейная интерполяция
$ echo -e "0 0\n1 1\n2 4" | lein run -- --linear --step 0.5
linear: 0.0000 0.0000
linear: 0.5000 0.5000
linear: 1.0000 1.0000
linear: 1.5000 2.5000
linear: 2.0000 4.0000

# Интерполяция Ньютона (y = x²)
$ echo -e "0 0\n1 1\n2 4\n3 9" | lein run -- --newton -n 3 --step 0.5
newton: 0.0000 0.0000
newton: 0.5000 0.2500
newton: 1.0000 1.0000
newton: 1.5000 2.2500
newton: 2.0000 4.0000
newton: 2.5000 6.2500
newton: 3.0000 9.0000

# Интерполяция Лагранжа
$ echo -e "0 0\n1 1\n2 4\n3 9" | lein run -- --lagrange -n 3 --step 0.5
lagrange: 0.0000 0.0000
lagrange: 0.5000 0.2500
lagrange: 1.0000 1.0000
lagrange: 1.5000 2.2500
lagrange: 2.0000 4.0000
lagrange: 2.5000 6.2500
lagrange: 3.0000 9.0000
```

---

## Тестирование

### Unit-тесты ([`test/interpolation/core_test.clj`](test/interpolation/core_test.clj))

Покрывают:
- корректность линейной интерполяции;
- корректность интерполяции Ньютона;
- корректность интерполяции Лагранжа;
- эквивалентность результатов Ньютона и Лагранжа;
- парсинг аргументов CLI;
- парсинг и форматирование I/O.

### Запуск

```bash
# Запуск тестов
$ lein test

# Проверка форматирования
$ lein cljfmt check
```

**Результат:** 7 тестов, 58 assertions, 0 failures.

---

## Выводы

В ходе лабораторной работы я:

- реализовал потоковую интерполяцию с тремя алгоритмами (линейная, Лагранж, Ньютон);
- применил **функциональный стиль**: чистые функции для алгоритмов, ленивые последовательности для потоковой обработки;
- разделил ответственность между модулями: парсинг, форматирование, алгоритмы, потоковая логика;
- использовал идиоматичные приёмы Clojure:
  - `loop/recur` для хвостовой рекурсии в вычислении разделённых разностей;
  - `reduce` для построения сумм в интерполяции Лагранжа;
  - `iterate` и `take-while` для ленивой генерации x-координат;
  - `defmulti/defmethod` для полиморфной диспетчеризации алгоритмов;
  - функции высшего порядка (`map`, `filter`, `mapcat`) для обработки коллекций;
- обеспечил **разделение I/O от бизнес-логики**: все алгоритмы — чистые функции без побочных эффектов;
- провёл рефакторинг для устранения дублирования кода и упрощения архитектуры.
